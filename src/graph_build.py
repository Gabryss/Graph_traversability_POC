"""
graph_build.py

Builds a coarse graph on top of a traversability map generated by environment.py.

For each block of cells (block_size x block_size), it:
  - averages traversability of non-wall cells
  - creates a node if at least one cell is traversable
  - connects neighbouring nodes ONLY if there is no wall between them
    (line-of-sight on the fine traversability map).

Project structure assumed:

  project_root/
    config/config.json
    src/environment.py
    src/graph_build.py
"""

from pathlib import Path
from typing import Optional, Tuple, List

import numpy as np
import networkx as nx
import matplotlib

# Headless backend (Docker / no display)
matplotlib.use("Agg")

from environment import EnvironmentGenerator, load_config
from visualization import TraversabilityVisualizer


class TraversabilityGraphBuilder:
    """
    Build a coarse graph from a traversability map by averaging blocks.
    Edges are only added when there is no wall between node centers.
    """

    def __init__(
        self,
        traversability: np.ndarray,
        neighbor_mode: str = "8",
        obstacle_threshold: float = 0.1,
        block_size: int = 2,
    ):
        """
        :param traversability: 2D numpy array in [0, 1]
        :param neighbor_mode:  "4" (von Neumann) or "8" (Moore) connectivity
                               between *nodes* (blocks)
        :param obstacle_threshold: cells with trav <= threshold are walls
        :param block_size:     size of blocks in cells (1=per cell, 2=2x2, ...)
        """
        self.traversability = traversability
        self.neighbor_mode = neighbor_mode
        self.obstacle_threshold = obstacle_threshold
        self.block_size = max(1, int(block_size))

        self.H, self.W = traversability.shape
        self.graph: Optional[nx.Graph] = None

    # ------------------------------------------------------------------ #
    # Graph construction
    # ------------------------------------------------------------------ #
    def _get_neighbors(self) -> List[Tuple[int, int]]:
        if self.neighbor_mode == "4":
            return [(1, 0), (-1, 0), (0, 1), (0, -1)]
        elif self.neighbor_mode == "8":
            return [
                (1, 0),
                (-1, 0),
                (0, 1),
                (0, -1),
                (1, 1),
                (1, -1),
                (-1, 1),
                (-1, -1),
            ]
        else:
            raise ValueError("neighbor_mode must be '4' or '8'")


    def build_graph(self) -> nx.Graph:
        """
        Build a coarse graph:

        - Each node represents a 3x3 cluster: center cell + its 8 neighbors
        - Clusters do NOT overlap (stride 3 in x and y)
        - Center cell must be traversable (traversability > obstacle_threshold)
        - Node attribute 'trav': average traversability of non-wall cells in cluster
        - Node attribute 'center': (x_center, y_center) in original cell coords
        - Neighbouring clusters with nodes are connected by edges only if
          the fine-grid line between centers contains no wall cells.
        """
        trav = self.traversability
        H, W = self.H, self.W

        # 3x3 clusters, stride 3 -> non-overlapping neighborhoods
        centers_x = list(range(1, W - 1, 3))
        centers_y = list(range(1, H - 1, 3))

        BW = len(centers_x)  # coarse width (in cluster indices)
        BH = len(centers_y)  # coarse height

        G = nx.Graph()
        neighbors = self._get_neighbors()

        # --- Create nodes ---
        for iy, cy in enumerate(centers_y):
            for ix, cx in enumerate(centers_x):
                # Center must be traversable (not wall)
                center_val = trav[cy, cx]
                if center_val <= self.obstacle_threshold:
                    continue

                cells: list[tuple[int, int]] = []
                values: list[float] = []

                # 3x3 neighborhood around center (cx, cy)
                for dy in [-1, 0, 1]:
                    for dx in [-1, 0, 1]:
                        x = cx + dx
                        y = cy + dy
                        if 0 <= x < W and 0 <= y < H:
                            cells.append((x, y))
                            if trav[y, x] > self.obstacle_threshold:
                                values.append(float(trav[y, x]))

                if not values:
                    # Should not happen since center is traversable,
                    # but guard anyway.
                    continue

                avg_trav = float(np.mean(values))

                # Node id in coarse (cluster) coordinates
                node_id = (ix, iy)

                # Store center position and cluster cells if needed
                G.add_node(
                    node_id,
                    trav=avg_trav,
                    center=(float(cx), float(cy)),
                    cells=cells,
                )

        # --- Create edges with LOS check ---
        for iy in range(BH):
            for ix in range(BW):
                node_id = (ix, iy)
                if node_id not in G:
                    continue

                for dx, dy in neighbors:
                    nbx = ix + dx
                    nby = iy + dy
                    nb_id = (nbx, nby)

                    if 0 <= nbx < BW and 0 <= nby < BH and nb_id in G:
                        # Avoid duplicating edges
                        if G.has_edge(node_id, nb_id):
                            continue

                        # Only link if there is no wall between centers
                        if self._line_between_nodes_is_free(G, node_id, nb_id):
                            t1 = G.nodes[node_id]["trav"]
                            t2 = G.nodes[nb_id]["trav"]
                            avg_t = 0.5 * (t1 + t2)
                            cost = 1.0 - avg_t
                            G.add_edge(node_id, nb_id, weight=cost)

        self.graph = G
        print(
            f"[INFO] Graph built with {G.number_of_nodes()} nodes and {G.number_of_edges()} edges "
            "(3x3 non-overlapping clusters)."
        )
        return G


    # ------------------------------------------------------------------ #
    # Line-of-sight / wall checking
    # ------------------------------------------------------------------ #
    def _line_between_nodes_is_free(
        self, G: nx.Graph, node_a: Tuple[int, int], node_b: Tuple[int, int]
    ) -> bool:
        """
        Check whether the straight line between node centers crosses any wall.

        Uses Bresenham on the fine grid. If any cell along the line has
        traversability <= obstacle_threshold, the line is considered blocked.
        """
        cx0, cy0 = G.nodes[node_a]["center"]
        cx1, cy1 = G.nodes[node_b]["center"]

        x0 = int(round(cx0))
        y0 = int(round(cy0))
        x1 = int(round(cx1))
        y1 = int(round(cy1))

        for x, y in self._bresenham_line(x0, y0, x1, y1):
            if not (0 <= x < self.W and 0 <= y < self.H):
                continue
            if self.traversability[y, x] <= self.obstacle_threshold:
                return False
        return True

    @staticmethod
    def _bresenham_line(x0: int, y0: int, x1: int, y1: int):
        """
        Integer Bresenham line from (x0, y0) to (x1, y1), inclusive.
        Yields (x, y) cell coordinates.
        """
        dx = abs(x1 - x0)
        sx = 1 if x0 < x1 else -1
        dy = -abs(y1 - y0)
        sy = 1 if y0 < y1 else -1
        err = dx + dy

        while True:
            yield x0, y0
            if x0 == x1 and y0 == y1:
                break
            e2 = 2 * err
            if e2 >= dy:
                err += dy
                x0 += sx
            if e2 <= dx:
                err += dx
                y0 += sy


# ---------------------------------------------------------------------- #
# Main: load config, load/reuse env map, build coarse graph, plot nodes
# ---------------------------------------------------------------------- #
def main():
    cfg = load_config()

    map_cfg = cfg.get("map", {})
    perlin_cfg = cfg.get("perlin", {})
    cave_cfg = cfg.get("cave", {})
    graph_cfg = cfg.get("graph", {})
    vis_cfg = cfg.get("visualization", {})

    width = int(map_cfg.get("width", 100))
    height = int(map_cfg.get("height", 100))
    map_generator = str(map_cfg.get("generator", "cave"))

    perlin_scale = float(perlin_cfg.get("scale", 30.0))
    perlin_octaves = int(perlin_cfg.get("octaves", 3))
    perlin_seed = int(perlin_cfg.get("seed", 0))

    cave_fill_prob = float(cave_cfg.get("fill_probability", 0.45))
    cave_birth_limit = int(cave_cfg.get("birth_limit", 4))
    cave_death_limit = int(cave_cfg.get("death_limit", 3))
    cave_steps = int(cave_cfg.get("steps", 5))
    cave_min_trav = float(cave_cfg.get("min_traversability", 0.3))

    neighbor_mode = str(graph_cfg.get("neighbor_mode", "8"))
    obstacle_threshold = float(graph_cfg.get("obstacle_threshold", 0.1))
    block_size = int(graph_cfg.get("block_size", 2))

    graph_output_path_str = vis_cfg.get(
        "graph_output_path", "traversability_graph_nodes.png"
    )
    graph_clusters_path_str = vis_cfg.get(
        "graph_clusters_output_path", "traversability_graph_clusters.png"
    )

    map_npy_path_str = vis_cfg.get("map_npy_path", "traversability_map.npy")
    show_flag = bool(vis_cfg.get("show", False))

    # Paths are relative to root/
    project_root = Path(__file__).resolve().parents[1]
    graph_output_path = project_root / graph_output_path_str
    graph_clusters_path = project_root / graph_clusters_path_str
    map_npy_path = project_root / map_npy_path_str

    # 1) Load existing traversability map if available, otherwise regenerate
    if map_npy_path.exists():
        print(f"[INFO] Loading existing traversability map from {map_npy_path}")
        trav = np.load(map_npy_path)
    else:
        print(
            f"[WARN] {map_npy_path} not found, regenerating environment "
            "with same config (deterministic if seed unchanged)."
        )
        env = EnvironmentGenerator(
            width=width,
            height=height,
            map_generator=map_generator,
            perlin_scale=perlin_scale,
            perlin_octaves=perlin_octaves,
            perlin_seed=perlin_seed,
            cave_fill_prob=cave_fill_prob,
            cave_birth_limit=cave_birth_limit,
            cave_death_limit=cave_death_limit,
            cave_steps=cave_steps,
            cave_min_traversability=cave_min_trav,
        )
        trav = env.generate_traversability_map()
        map_npy_path_str = vis_cfg.get("map_npy_path", "traversability_map.npy")
        map_npy_path = project_root / map_npy_path_str
        np.save(map_npy_path, env.traversability)
        print(f"[INFO] Saved traversability map to: {map_npy_path}")

    # 2) Build coarse graph with LOS constraints
    builder = TraversabilityGraphBuilder(
        traversability=trav,
        neighbor_mode=neighbor_mode,
        obstacle_threshold=obstacle_threshold,
        block_size=block_size,
    )
    builder.build_graph()

    viz = TraversabilityVisualizer()
    viz.plot_graph_overlay(
        traversability=trav,
        graph=builder.graph,
        save_path=graph_output_path,
        show=show_flag,
        node_size=10.0,
        edge_color="red",
        edge_width=1.0,
        edge_alpha=0.6,
    )

    viz.plot_graph_clusters(
        traversability=trav,
        graph=builder.graph,
        save_path=graph_clusters_path,
        show=show_flag,
    )


if __name__ == "__main__":
    main()
